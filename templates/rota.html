<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rota</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #mapaContainer {
            position: relative;
        }

        canvas {
            border: 1px solid #000;
            background-color: #fff;
        }

        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <h1>Rota para <span id="destinoDisplay"></span></h1>
    <div id="mapaContainer">
        <canvas id="mapaCanvas" width="800" height="600"></canvas>
    </div>
    <button onclick="window.location.href='/'">Voltar</button>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const rota = JSON.parse(localStorage.getItem('rota')) || [];
            const arestas = JSON.parse(localStorage.getItem('arestas')) || [];
            const destino = localStorage.getItem('destino');
            document.getElementById('destinoDisplay').textContent = destino;

            const canvas = document.getElementById('mapaCanvas');
            const ctx = canvas.getContext('2d');

            // Variáveis para panning
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let offsetX = 0;
            let offsetY = 0;

            // Evento para iniciar o panning
            canvas.addEventListener('mousedown', (e) => {
                isPanning = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
            });

            // Evento para parar o panning
            canvas.addEventListener('mouseup', () => {
                isPanning = false;
            });

            canvas.addEventListener('mouseout', () => {
                isPanning = false;
            });

            // Evento para mover o canvas durante o panning
            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    offsetX = e.clientX - startX;
                    offsetY = e.clientY - startY;
                    draw();
                }
            });

            // Eventos de toque para panning em dispositivos móveis
            canvas.addEventListener('touchstart', function (e) {
                isDragging = true;
                const touch = e.touches[0];
                dragStartX = touch.clientX - offsetX;
                dragStartY = touch.clientY - offsetY;
            });

            canvas.addEventListener('touchmove', function (e) {
                if (isDragging) {
                    const touch = e.touches[0];
                    offsetX = touch.clientX - dragStartX;
                    offsetY = touch.clientY - dragStartY;
                    draw();
                }
            });

            canvas.addEventListener('touchend', function () {
                isDragging = false;
            });

            // Definindo as posições das salas
            const positionsTerreo = {
                "Portaria": [400, 550],
                "C0": [400, 500],
                "TI": [333, 500],
                "Xerox": [216, 500],
                "Lab. Info. Geral": [150, 550],
                "Escada A": [100, 500],
                "Escada B": [593, 100],
                "Escada C": [700, 220],
                "Escada D": [700, 500],
                "Escada F": [295, 40],
                "Elevador": [325, 40],
                "C1": [150, 500],
                "C2": [150, 465],
                "C3": [150, 409],
                "C4": [150, 353],
                "C5": [150, 325],
                "C6": [150, 298],
                "C7": [150, 271],
                "C8": [150, 222],
                "C9": [150, 173],
                "Ref./Cantina": [150, 150],
                "C10": [255, 150],
                "C11": [360, 150],
                "C12": [400, 150],
                "C13": [593, 150],
                "Biblioteca": [650, 150],
                "C14": [650, 185],
                "C15": [650, 220],
                "C16": [650, 325],
                "C17": [650, 409],
                "C18": [650, 465],
                "C19": [650, 500],
                "C20": [600, 500],
                "C21": [255, 119],
                "C22": [255, 71],
                "C23": [295, 71],
                "C24": [325, 71],
                "C25": [255, 10],
                "Estacionamento": [500, 10],
                "Prédio M.B.": [130, 10],
                "WC/Vest. M": [100, 222],
                "WC/Vest. F": [100, 173],
                "WC Familia": [360, 119],
                "WC Cantina": [305, 119],
                "Sala Prof.": [400, 119],
                "Sala Prof. 1": [100, 298],
                "Sala Prof. 2": [100, 271],
                "Centro": [400, 325],
                "Sala Estágio": [600, 550],
                "Pastoral": [100, 465],
                "Diretoria": [100, 409],
                "Lab. AutoCad": [100, 353],
                "Social": [700, 465],
                "Secretaria": [700, 409],
                "Coordenação": [700, 325],
                "Cant. Leitura": [700, 185],
                "Quadra": [70, 150],
                "Sala Arquivo": [360, 71],
                "Capela": [100, 550],
                "Corredor S.J.": [70, 325],
            };

            const positionsFirst = {
                "Escada A": [100, 500],
                "Escada B": [593, 100],
                "Escada C": [700, 220],
                "Escada D": [700, 500],
                "Escada F": [295, 40],
                "Elevador": [325, 40],
            }

            // Função para desenhar o mapa
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

                // Aplica o deslocamento
                ctx.save();
                ctx.translate(offsetX, offsetY);

                // Desenhar as arestas
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                arestas.forEach(([u, v, weight]) => {
                    if (positionsTerreo[u] && positionsTerreo[v]) {
                        const [x1, y1] = positionsTerreo[u];
                        const [x2, y2] = positionsTerreo[v];
                        ctx.beginPath();
                        ctx.moveTo(x1 + 10, y1 + 10);
                        ctx.lineTo(x2 + 10, y2 + 10);
                        ctx.stroke();
                    }
                });

                // Desenhar as salas
                ctx.fillStyle = 'lightgrey';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;

                Object.keys(positionsTerreo).forEach(key => {
                    const [x, y] = positionsTerreo[key];
                    const width = 20;
                    const height = 20;
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;

                    // Verificar se é uma escada e mudar a cor para verde se estiver na rota
                    if (rota.includes(key) && key.startsWith('Escada')) {
                        ctx.fillStyle = 'green';

                        // Tornar a escada clicável apenas se estiver na rota
                        canvas.addEventListener('click', function clickHandler(event) {
                            const rect = canvas.getBoundingClientRect();
                            const clickX = event.clientX - rect.left;
                            const clickY = event.clientY - rect.top;

                            if (
                                clickX >= x + offsetX &&
                                clickX <= x + offsetX + width &&
                                clickY >= y + offsetY &&
                                clickY <= y + offsetY + height
                            ) {
                                alert(`Você clicou na ${key}`);
                                // Remove o listener de clique para evitar múltiplas execuções
                                canvas.removeEventListener('click', clickHandler);
                            }
                        });

                    } else {
                        ctx.fillStyle = 'lightgrey';
                    }

                    ctx.beginPath();
                    ctx.rect(x, y, width, height);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'black';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(key, centerX, y);
                    ctx.fillStyle = 'lightgrey';
                
                });

                // Desenha a rota com uma linha vermelha
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 5;
                ctx.beginPath();

                if (rota.length > 0) {
                    const start = positionsTerreo[rota[0]];
                    ctx.moveTo(start[0] + 10, start[1] + 10);

                    rota.forEach(sala => {
                        const [x, y] = positionsTerreo[sala];
                        ctx.lineTo(x + 10, y + 10);
                    });

                    ctx.stroke();

                    const [endX, endY] = positionsTerreo[rota[rota.length - 1]];
                    const arrowSize = 20;
                    const angle = Math.atan2(
                        endY - positionsTerreo[rota[rota.length - 2]][1],
                        endX - positionsTerreo[rota[rota.length - 2]][0]
                    );

                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.moveTo(endX + 10, endY + 10);
                    ctx.lineTo(
                        endX + 10 - arrowSize * Math.cos(angle - Math.PI / 6),
                        endY + 10 - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        endX + 10 - arrowSize * Math.cos(angle + Math.PI / 6),
                        endY + 10 - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore(); // Restaura o estado do canvas
            }
            // Chama a função draw para desenhar o mapa
            draw();
        });
    </script>
</body>

</html>